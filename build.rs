use std::collections::HashMap;
use std::fs;

fn main() {
    // Define hardforks that contain system contracts (matching hardfork_to_dir_name function)
    let hardforks = vec![
        "bruno",
        "euler",
        "feynman",
        "feynman_fix",
        "gibbs",
        "kepler",
        "luban",
        "mirror_sync",
        "moran",
        "niels",
        "planck",
        "plato",
        "ramanujan",
        "haber_fix",
        "bohr",
        "pascal",
        "lorentz",
        "maxwell",
    ];

    // Rerun if any of the hardfork directories change
    for hardfork in &hardforks {
        println!("cargo:rerun-if-changed=src/system_contracts/{}", hardfork);
    }

    let contracts_dir = "src/system_contracts";
    let mut contract_data = HashMap::new();

    // Get all hardfork directories
    if let Ok(entries) = fs::read_dir(contracts_dir) {
        for entry in entries {
            if let Ok(entry) = entry {
                let path = entry.path();
                if path.is_dir() {
                    let hardfork_name = path.file_name().unwrap().to_string_lossy();

                    // Skip the abi.rs file and other non-hardfork directories
                    if hardfork_name == "abi" || hardfork_name.starts_with('.') {
                        continue;
                    }

                    // Process mainnet and chapel subdirectories
                    for network in ["mainnet", "chapel"] {
                        let network_path = path.join(network);
                        if network_path.exists() {
                            if let Ok(contract_files) = fs::read_dir(&network_path) {
                                for contract_file in contract_files {
                                    if let Ok(contract_file) = contract_file {
                                        let contract_path = contract_file.path();
                                        if contract_path.is_file() {
                                            let contract_name = contract_path
                                                .file_name()
                                                .unwrap()
                                                .to_string_lossy();

                                            // Read the contract hex data
                                            if let Ok(hex_data) = fs::read_to_string(&contract_path)
                                            {
                                                let hex_data = hex_data.trim();

                                                // Store the contract data
                                                let key = format!(
                                                    "{}_{}_{}",
                                                    hardfork_name, network, contract_name
                                                );
                                                contract_data.insert(key, hex_data.to_string());
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    // Generate the Rust code
    let mut code = String::new();
    code.push_str("// Auto-generated by build.rs - DO NOT EDIT\n");
    code.push_str("use std::collections::HashMap;\n");
    code.push_str("use lazy_static::lazy_static;\n\n");

    code.push_str("lazy_static! {\n");
    code.push_str("    pub static ref EMBEDDED_CONTRACTS: HashMap<String, &'static str> = {\n");
    code.push_str("        let mut map = HashMap::new();\n");

    for (key, hex_data) in &contract_data {
        code.push_str(&format!("        map.insert(\"{}\".to_string(), \"{}\");\n", key, hex_data));
    }

    code.push_str("        map\n");
    code.push_str("    };\n");
    code.push_str("}\n");

    // Write the generated code
    fs::write("src/system_contracts/embedded_contracts.rs", code).unwrap();
}
